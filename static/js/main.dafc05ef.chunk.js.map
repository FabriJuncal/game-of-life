{"version":3,"sources":["components/BtnGuardarCargar.jsx","App.js","reportWebVitals.js","index.js"],"names":["BtnGuardarCargar","operacion","texto","nroGrilla","grillaSeleccionado","actGrillaSeleccionado","guardarCargarGrilla","actualizarRecorrido","grillaGuardada","JSON","parse","localStorage","getItem","length","Button","id","variant","color","onClick","e","operaciones","App","actualizarTamanioGrilla","p_cantColumnas","p_cantFilas","p_grilla","grillaBase","nroColumnas","parseInt","nroFilas","actualizarCantColumnas","actualizarCantFila","i","arrayColumnas","Array","from","push","actualizarGrilla","actualizarContTurnos","nroTurnoActual","nroGrillaGuardada","setItem","stringify","grilla","contadorTurnos","nroFila","nroTurno","useState","cantColumnas","cantFila","recorrido","tiempoTurno","actualizarTiempoTurno","recorridoRef","useRef","current","turnoActualRef","correrSimulación","useCallback","g","produce","grillaCopia","j","vecinos","forEach","x","y","fila_i","columna_j","setTimeout","useEffect","Grid","container","direction","justifyContent","alignItems","Hidden","lgUp","Typography","gutterBottom","item","lg","spacing","disabled","style","width","Slider","defaultValue","step","marks","value","label","min","max","valueLabelDisplay","onChange","tiempo","target","textContent","isNaN","TextField","type","helperText","display","alignContent","gridTemplateColumns","map","filas","columnas","nuevaGrilla","actualizarEstadoGrilla","height","backgroundColor","undefined","border","borderRadius","margin","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.dafc05ef.chunk.js","sourcesContent":["/*Componente Personalizado para Cargar o Guardar las Grillas en el LocalStorage*/\r\nimport Button from '@material-ui/core/Button';\r\n\r\nconst BtnGuardarCargar = ({nroGrilla, grillaSeleccionado, actGrillaSeleccionado, guardarCargarGrilla, actualizarRecorrido}) => {\r\n  const grillaGuardada = JSON.parse(localStorage.getItem('grilla'+nroGrilla)) ? JSON.parse(localStorage.getItem('grilla'+nroGrilla)) : [];\r\n  let operacion, texto;\r\n\r\n  if(nroGrilla !== grillaSeleccionado && grillaGuardada.length > 0){\r\n    operacion = 'cargar';\r\n    texto = 'Cargar  '+nroGrilla;\r\n  }if(nroGrilla !== grillaSeleccionado && grillaGuardada.length === 0){\r\n    operacion = 'guardar';\r\n    texto = 'Guardar '+nroGrilla;\r\n  }else if(nroGrilla === grillaSeleccionado){\r\n    operacion = 'guardar';\r\n    texto = 'Guardar '+nroGrilla;\r\n  }\r\n\r\n\r\n  return(\r\n    <Button id={\"btnGuardarCargar-\"+nroGrilla} variant={grillaSeleccionado === nroGrilla ? 'contained' : 'outlined'} color='primary'\r\n      onClick={(e)=>{\r\n        guardarCargarGrilla(nroGrilla, operacion);\r\n        actGrillaSeleccionado(nroGrilla);\r\n        actualizarRecorrido(false);\r\n      }}\r\n   >{texto}</Button>\r\n  )\r\n}\r\n\r\nexport default BtnGuardarCargar;","import React, {useState, useRef, useEffect, useCallback} from \"react\";\r\n// La librería Immer ayudará a seguir el paradigma de datos inmutables\r\n// y hará que la actualización de un Estado sea mucho mas sencilla\r\nimport produce from \"immer\";\r\n// La librería Material UI se utilizará para tener un estilo definido para los componentes\r\nimport Button from '@material-ui/core/Button';\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Slider from '@material-ui/core/Slider';\r\nimport TextField from '@material-ui/core/TextField';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport Hidden from '@material-ui/core/Hidden';\r\nimport NavigateNextIcon from '@material-ui/icons/NavigateNext';\r\n// Botones personalizados de Guardar/Cargar Grilla\r\nimport BtnGuardarCargar from '../src/components/BtnGuardarCargar';\r\n\r\n// Se define las operaciones para poder indentificar las células vecinas\r\n// Si realizamos una suma con cada uno de estos array con la posición en la que estamos ubicados, obtendremos las posiciones de las 8 células vecinas que puede tener cada una de estas\r\n// Ejemplo:\r\n//    -1,-1 | -1,0 | -1,1\r\n//   _______|______|______\r\n//     0,-1 |Célula| 0,1\r\n//   _______|______|______\r\n//     1,-1 |  1,0 | 1,1\r\n\r\nconst operaciones = [\r\n  [-1, -1], // Noroeste\r\n  [-1, 0],  // Norte\r\n  [-1, 1],  // Noreste\r\n  [0, 1],   // Este\r\n  [1, 1],   // Sureste\r\n  [1, 0],   // Sur\r\n  [1, -1],  // Suroeste\r\n  [0, -1],  // Oeste\r\n]\r\n\r\nfunction App() {\r\n\r\n// =============================================================================================================================== \r\n/*Definición de Funciones*/\r\n\r\n  // Función que se utiliza para actualizar el tamaño de la grilla cada vez que se modifican los valores de las Filas y Columnas\r\n  const actualizarTamanioGrilla = (p_cantColumnas, p_cantFilas, p_grilla = []) => {\r\n  \r\n    // Se pausa la simulación para no generar ningún error al modificar las dimensiones de la grilla\r\n    actualizarRecorrido(false);\r\n\r\n    grillaBase = p_grilla;\r\n    \r\n    let nroColumnas = parseInt(p_cantColumnas != null ? p_cantColumnas : 1);\r\n    let nroFilas = parseInt(p_cantFilas != null ? p_cantFilas : 1);\r\n\r\n    actualizarCantColumnas(nroColumnas);\r\n    actualizarCantFila(nroFilas);\r\n\r\n    // Si se pasa como parametro una grilla cargada, no se vuelven a generar las Filas y Columnas\r\n    if( grillaBase.length === 0){\r\n      // Iteramos sobre el la cantidad de Filas\r\n      for (let i = 0; i < (nroFilas); i++){\r\n  \r\n        // Creamos la cantidad de Columnas asignadas con el valor 0\r\n        let arrayColumnas = Array.from(Array(nroColumnas), () => 0);\r\n        // Cargamos las Columnas dentro de cada Fila\r\n        grillaBase.push(arrayColumnas);\r\n        actualizarGrilla(grillaBase);\r\n        // Reiniciamos el contador de turnos\r\n        actualizarContTurnos(0);\r\n        nroTurnoActual = 0;\r\n      }\r\n    }else{\r\n      actualizarGrilla(grillaBase);\r\n    }\r\n\r\n  }\r\n\r\n  // Función que se utiliza para actualizar el estado de la Grilla (Es decir, con esta función podemos seleccionar cada célular e ir reviviendolas o matandolas)\r\n  const actualizarEstadoGrilla = (i,j) => {\r\n      // Utilizamos la función \"produce\" de la librería \"Immer\" para actualizar el estado \"grilla\" de una manera muy sensilla\r\n      const nuevaGrilla = produce(grilla, grillaCopia => {\r\n        // Si la posición de la grilla que pasamos como parametro tiene un valor de 1, este se actualiza 0 y viceversa\r\n        grillaCopia[i][j] = grillaCopia[i][j] > 0 ? 0 : 1;\r\n      });\r\n      actualizarGrilla(nuevaGrilla);\r\n  }\r\n\r\n  // Función que Inicia o Detiene la Simulación\r\n  const actEstadoBtnSimulacion = () => {\r\n    actualizarRecorrido(!recorrido);\r\n    if(!recorrido){\r\n      recorridoRef.current = true;\r\n      correrSimulación();\r\n    }\r\n  }\r\n\r\n  // Función que Carga o Almacena las grillas y el contador de turnos en el Local Storage según el Slot que se haya seleccionado\r\n  const guardarCargarGrilla = (nroGrillaGuardada, operacion) => {\r\n\r\n    if(operacion === 'guardar'){\r\n        localStorage.setItem('grilla'+nroGrillaGuardada, JSON.stringify(grilla));\r\n        localStorage.setItem('nroTurno'+nroGrillaGuardada, contadorTurnos);\r\n    }\r\n\r\n    if(operacion === 'cargar'){\r\n      let nroFila, nroColumnas;\r\n      let grillaGuardada = JSON.parse(localStorage.getItem('grilla'+nroGrillaGuardada)) ? JSON.parse(localStorage.getItem('grilla'+nroGrillaGuardada)) : [];\r\n      let nroTurno = parseInt(localStorage.getItem('nroTurno'+nroGrillaGuardada)) > 0 ? parseInt(localStorage.getItem('nroTurno'+nroGrillaGuardada)) : 0;\r\n      actualizarContTurnos(nroTurno);\r\n      nroColumnas = grillaGuardada.length > 0 ? grillaGuardada[0].length : 50;\r\n      nroFila = grillaGuardada.length  > 0 ? grillaGuardada.length : 30;\r\n      actualizarTamanioGrilla(nroColumnas, nroFila, grillaGuardada);\r\n    }\r\n  }\r\n\r\n  // =============================================================================================================================== \r\n  /*Definición de Hooks*/\r\n  const [cantColumnas, actualizarCantColumnas] = useState(0);\r\n  const [cantFila, actualizarCantFila] = useState(0);\r\n  const [grilla, actualizarGrilla] = useState([]);\r\n  const [grillaSeleccionado, actGrillaSeleccionado] = useState(1);\r\n  const [recorrido, actualizarRecorrido] = useState(false);\r\n  const [tiempoTurno, actualizarTiempoTurno] = useState(300);\r\n  const [contadorTurnos, actualizarContTurnos] = useState(0);\r\n\r\n\r\n  // Se utiliza el Hook \"useRef\" para que no se pierda la asignación de las variable después de cada renderizado.\r\n  // Estas variables se utilizarán en el proceso de ejecución de la simulación y por lo tanto se necesita que persistan en el tiempo con sus valores\r\n  const recorridoRef = useRef(recorrido);\r\n  recorridoRef.current = recorrido;\r\n\r\n  const turnoActualRef = useRef(contadorTurnos);\r\n  turnoActualRef.current = contadorTurnos;\r\n\r\n  // La función correrSimulación() ejecuta la simulación de la evolución de las células por turno\r\n  // Se utiliza el Hook \"useCallback\" para almacenar la función en memoria y no volver a cargar la función cada vez que React renderice los componentes, ya que la función contiene muchos calculos.\r\n  // Esta es una buena manera de hacer el código mas eficiente\r\n  const correrSimulación = useCallback(() => {\r\n\r\n      if(!recorridoRef.current){\r\n        return;\r\n      }\r\n\r\n      actualizarGrilla(g => {\r\n        // Se utiliza la función \"produce\" de la librería \"Immer\" para actualizar el estado \"grilla\" de una manera muy sensilla\r\n        return produce(g,  grillaCopia =>{\r\n          // Recorre cada celda de la grilla (Sería cada célula)\r\n          for (let i = 0; i < cantFila; i++){\r\n            for (let j = 0; j < cantColumnas; j++){\r\n              let vecinos = 0;\r\n              // Busca cadá célula vecina.\r\n              // Se utiliza el array \"operaciones\" definido previamente para realizar la suma con la posición en la que se encuentra la secuencia (Es decir, la célula del centro)\r\n              // y de esta manera obtener las posiciones de las 8 células vecinas que tiene cada una de estas (Excluyendo las células de los bordes)\r\n              operaciones.forEach(([x , y]) => {\r\n                const fila_i = i + x;\r\n                const columna_j = j + y;\r\n                \r\n                // Validamos que las células vecinas se encuentren dentro del rango de la grilla\r\n                if(fila_i >= 0 && fila_i < cantFila && columna_j >= 0 && columna_j < cantColumnas){\r\n                  // Se suma cadá valor de las células vecinas encontradas\r\n                  // (Cada célula viva vale 1 y las muertas valen 0, por lo tanto si se encuentra 3 células vecinas vivas, al finalizar la secuencia la variable \"vecino\" tendría que valer 3)\r\n                  vecinos += g[fila_i][columna_j];\r\n                  \r\n                }\r\n                \r\n              });\r\n\r\n              // Una vez terminado las repeticiones para obtener el valor de las 8 células vecinas  validamos:\r\n              // Si la célula analizada contiene menos de 2 células vecinas vivas o contiene más de 3 células vecinas vivas, esta muere \r\n              // (Por lo tanto se le agrega el valor de 0 en la posición de la grila)\r\n              if(vecinos < 2 || vecinos > 3){\r\n                grillaCopia[i][j] = 0;\r\n              \r\n              // Si la célula analizada se encuentra muerta (con el valor 0) y se encuentra que tiene 3 células vecinas (con el valor 1), Esta revive\r\n              // (Por lo tanto se le agrega el valor de 1 en la posición de la grila)\r\n              }else if (g[i][j] === 0 && vecinos === 3){\r\n                grillaCopia[i][j] = 1;\r\n              }\r\n\r\n            }\r\n            \r\n          }\r\n          \r\n        });\r\n      });\r\n   // Ejecuta la simulación de la evolución de las células por turno deacuerdo al tiempo que se le este pasando la función setTimeout()\r\n      setTimeout(() => {\r\n        correrSimulación();\r\n    // Se lleva la cuenta de los turnos que se van ejecutando\r\n        nroTurnoActual = turnoActualRef.current + 1;\r\n        actualizarContTurnos(nroTurnoActual);\r\n      }, tiempoTurno);\r\n\r\n      \r\n    },\r\n    [cantColumnas,cantFila, tiempoTurno, contadorTurnos]);\r\n\r\n// ===============================================================================================================================\r\n  /* Este código inicializa la grilla con los valores preestablecidos */\r\n\r\n  let grillaBase = [];\r\n  let nroTurnoActual = 0;\r\n\r\n  useEffect(()=>{\r\n    actualizarTamanioGrilla(50,30);\r\n  }, []);\r\n\r\n// ===============================================================================================================================\r\n  return (\r\n\r\n    <>\r\n      <Grid container direction=\"column\" justifyContent=\"center\" >\r\n        <Grid container direction=\"row\" justifyContent=\"space-evenly\" alignItems=\"center\">\r\n        <Hidden lgUp>\r\n          <Typography id=\"discrete-slider-small-steps\" gutterBottom>\r\n              Simulación\r\n          </Typography>\r\n        </Hidden>\r\n          <Grid container direction=\"row\" justifyContent=\"center\" item lg={3}  spacing={1}>\r\n            <Grid item lg={4} >\r\n            {/* Botón de Empezar/Parar simulación\r\n                Al hacer click sobre el botón, este detecta si se se quiere empezar la simulación o se quiere parar\r\n            */}\r\n              <Button variant=\"contained\" color=\"primary\"\r\n                disabled={cantColumnas === 0 || cantFila === 0 ? true : false}\r\n                onClick={()=>{actEstadoBtnSimulacion()}}\r\n                style={{width: '100%'}}\r\n              >{recorrido ? 'Parar' : 'Empezar'}</Button>\r\n            </Grid>\r\n            <Grid item lg={4} >\r\n            {/* Botón de Siguiente Turno\r\n                Al hacer click sobre el botón, se avanza al siguiente turno en la simulación\r\n            */}\r\n              <Button variant=\"contained\" color=\"primary\"\r\n                  disabled={cantColumnas === 0 || cantFila === 0 ? true : false}\r\n                  onClick={()=>{\r\n                    actualizarRecorrido(false);\r\n                    recorridoRef.current = true;\r\n                    correrSimulación();\r\n                    recorridoRef.current = false;\r\n                  }}\r\n              ><NavigateNextIcon/></Button>\r\n            </Grid>\r\n            <Grid item lg={4} >\r\n            {/* Botón Restablecer Células y dimensión de la Grilla\r\n                Al hacer click sobre el botón, este restablece las células y el tamaño de la grilla a los valores predefinidos al inicio\r\n            */}\r\n              <Button variant=\"contained\" color=\"primary\"\r\n                onClick={()=>{\r\n                  actualizarTamanioGrilla(50,30);\r\n                  actualizarContTurnos(0);\r\n                  nroTurnoActual = 0;\r\n                }}\r\n              >Restablecer</Button>\r\n            </Grid>\r\n          </Grid>\r\n          <Hidden lgUp>\r\n            <Typography id=\"discrete-slider-small-steps\" gutterBottom>\r\n              Grillas\r\n            </Typography>\r\n          </Hidden>\r\n          <Grid container direction=\"row\" justifyContent=\"center\" item lg={4}  spacing={6}>\r\n            <Grid item lg={3}  >\r\n              {/* Slot 1 para cargar o almacenar la Grilla en el Local Storage\r\n                  Al hacer click sobre el botón este verificará que el Slot se encuentre vació o no,\r\n                  y si ya lo tenemos seleccionado. Dependiendo de estos factores se podrá Almacenar o Cargar la grilla\r\n              */}\r\n              <BtnGuardarCargar\r\n                nroGrilla={1}\r\n                grillaSeleccionado={grillaSeleccionado}\r\n                actGrillaSeleccionado={actGrillaSeleccionado}\r\n                guardarCargarGrilla={guardarCargarGrilla}\r\n                actualizarRecorrido={actualizarRecorrido}\r\n              />\r\n            </Grid>\r\n            <Grid item lg={3} >\r\n              {/* Slot 2 para cargar o almacenar la Grilla en el Local Storage\r\n                  Al hacer click sobre el botón este verificará que el Slot se encuentre vació o no,\r\n                  y si ya lo tenemos seleccionado. Dependiendo de estos factores se podrá Almacenar o Cargar la grilla\r\n              */}\r\n              <BtnGuardarCargar\r\n                nroGrilla={2}\r\n                grillaSeleccionado={grillaSeleccionado}\r\n                actGrillaSeleccionado={actGrillaSeleccionado}\r\n                guardarCargarGrilla={guardarCargarGrilla}\r\n                actualizarRecorrido={actualizarRecorrido}\r\n              />\r\n            </Grid>\r\n            <Grid item lg={3} >\r\n              {/* Slot 3 para cargar o almacenar la Grilla en el Local Storage\r\n                  Al hacer click sobre el botón este verificará que el Slot se encuentre vació o no,\r\n                  y si ya lo tenemos seleccionado. Dependiendo de estos factores se podrá Almacenar o Cargar la grilla\r\n              */}\r\n              <BtnGuardarCargar\r\n                nroGrilla={3}\r\n                grillaSeleccionado={grillaSeleccionado}\r\n                actGrillaSeleccionado={actGrillaSeleccionado}\r\n                guardarCargarGrilla={guardarCargarGrilla}\r\n                actualizarRecorrido={actualizarRecorrido}\r\n              />\r\n          </Grid>\r\n          </Grid>\r\n          <Grid  item lg={2} >\r\n              {/* Slider para configurar el tiempo de ejecución de la simulación */}\r\n              <Typography id=\"discrete-slider-small-steps\" gutterBottom>\r\n              Tiempo de Ejecución\r\n              </Typography>\r\n              <Slider\r\n                defaultValue={300}\r\n                aria-labelledby=\"discrete-slider-small-steps\"\r\n                step={100}\r\n                marks={[\r\n                  {value: 100,label: '0,1s'},\r\n                  {value: 500,label: '0,5s'},\r\n                  {value: 1000,label: '1s'}\r\n                ]}\r\n                min={100}\r\n                max={1000}\r\n                valueLabelDisplay=\"auto\"\r\n                onChange={(e) => {\r\n                  let tiempo = parseInt(e.target.textContent);\r\n                  if(!isNaN(tiempo) && tiempo !== 0){\r\n                    actualizarTiempoTurno(tiempo);\r\n                    actualizarRecorrido(false);\r\n                  }\r\n                }}\r\n              />\r\n          </Grid>\r\n          <Grid container direction=\"column\" alignItems=\"center\" item lg={3} >\r\n          {/* Campos para configurar el Tamaño de la Grilla */}\r\n            <Typography id=\"discrete-slider-small-steps\" gutterBottom>\r\n            Tamaño de la Grilla\r\n            </Typography>\r\n            <Grid container direction=\"row\" justifyContent=\"center\" alignItems=\"center\" spacing={2}>\r\n              <Grid item lg={5} >\r\n                <TextField id=\"n-filas\" label=\"Filas\"\r\n                  type=\"number\"\r\n                  value={cantFila}\r\n                  helperText=\"Valores permitidos entre 0 y 100\"\r\n                  onChange={(e) => {\r\n                    if( 1 <= e.target.value && e.target.value <= 100){\r\n                      actualizarTamanioGrilla(cantColumnas, e.target.value ? e.target.value : 0);\r\n                    }\r\n\r\n                  }}\r\n                />\r\n              </Grid>\r\n              <Grid item lg={5} >\r\n                <TextField  id=\"n-columnas\" label=\"Columnas\" \r\n                  type=\"number\"\r\n                  value={cantColumnas}\r\n                  helperText=\"Valores permitidos entre 0 y 100\"\r\n                  onChange={(e) => {\r\n                    if( 1 <= e.target.value && e.target.value <= 100){\r\n                      actualizarTamanioGrilla(e.target.value ? e.target.value : 0, cantFila);\r\n                    }\r\n                  }}\r\n                />\r\n              </Grid>\r\n            </Grid>\r\n          </Grid>\r\n        </Grid>       \r\n        <Grid  container direction=\"column\" justifyContent=\"center\" alignItems=\"center\">\r\n            <Typography variant=\"overline\" display=\"block\" gutterBottom>\r\n              Turno: {contadorTurnos}\r\n            </Typography>\r\n          </Grid>  \r\n        <Grid container direction=\"column\" alignContent=\"center\">\r\n          <Grid id=\"grillaSimulacion\"  item lg>\r\n            {/* Grilla donde se verán el conjunto de células */}\r\n            <div\r\n              // Una vez que tenemos la 1er columna armada utilizamos Grid para repetir/crear la cantidad de Columnas que se asignó\r\n              style={{\r\n                display: \"grid\",\r\n                gridTemplateColumns: `repeat(${cantColumnas}, 25px)`\r\n              }}\r\n            >\r\n              {/* Iteramos sobre el array \"grilla\" y \"filas\" para poder ir agregando cada célula en cada fila y de este modo armar una columna */}\r\n              {grilla.map((filas, i) => \r\n                filas.map((columnas, j) => (\r\n                  <div\r\n                    key={`${i}-${j}`}\r\n                    onClick={()=>{actualizarEstadoGrilla(i,j)}} // Al hacer click en una célula, esta muere o revive dependiendo del estado actual\r\n                    style={{\r\n                      width: 20,\r\n                      height: 20,\r\n                      backgroundColor: grilla[i][j] ? \"#007bff\" : undefined, // Si el valor de la posición es 1, se pinta la celula de color Azul\r\n                      border: \"solid 1px #007bff\",\r\n                      borderRadius: '20px',\r\n                      margin: '3px 5px'\r\n                    }}\r\n                  />\r\n                ))\r\n              )}\r\n            </div>\r\n          </Grid> \r\n         </Grid>\r\n      </Grid>\r\n    </>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","const reportWebVitals = onPerfEntry => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}